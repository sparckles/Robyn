export const description =
  'Learn how to implement Server-Sent Events (SSE) in Robyn for real-time server-to-client communication.'

## Server-Sent Events (SSE) {{ tag: 'SSE', label: 'Server-Sent Events' }}

<Row>
<Col>
After learning about [form data handling](/documentation/en/api_reference/form_data), Batman realized he needed a way to push real-time updates to his crime monitoring dashboard. Criminals don't wait for Batman to refresh his browser!

He discovered Server-Sent Events (SSE) - a perfect solution for one-way communication from server to client over HTTP. SSE allows Batman to stream live data to his dashboard without the complexity of full bidirectional communication.

"This is exactly what I need for my crime alerts!" Batman exclaimed. "I can push updates to the dashboard instantly when new crimes are detected."

Server-Sent Events are ideal for:
- Real-time notifications
- Live data feeds
- Progress updates
- Chat applications (server-to-client only)
- Dashboard updates
- Log streaming
</Col>
<Col sticky>

<CodeGroup title="SSE Response" tag="GET" label="/events">

```python {{ title: 'Basic SSE Stream' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events")
def stream_events(request):
    def event_generator():
        for i in range(10):
            yield SSE_Message(f"Event {i}", id=str(i))
            time.sleep(1)
    
    return SSE_Response(event_generator())
```

```python {{ title: 'JSON Data Stream' }}
from robyn import Robyn, SSE_Response, SSE_Message
import json
import time

app = Robyn(__file__)

@app.get("/events/json")
def stream_json_events(request):
    def json_event_generator():
        for i in range(5):
            data = {
                "id": i,
                "message": f"Update {i}",
                "timestamp": time.time()
            }
            yield SSE_Message(
                json.dumps(data), 
                event="update", 
                id=str(i)
            )
            time.sleep(2)
    
    return SSE_Response(json_event_generator())
```

</CodeGroup>
</Col>
</Row>

---

## SSE Message Format {{ tag: 'SSE_Message', label: 'Message Format' }}

<Row>
<Col>
The `SSE_Message` class provides a structured way to format Server-Sent Events. You can specify the message data, event type, and unique identifier.

**SSE_Message Parameters:**
- `data`: The message content (required)
- `event`: Event type for client-side filtering (optional)
- `id`: Unique identifier for the message (optional)
- `retry`: Reconnection time in milliseconds (optional)
</Col>
<Col sticky>

<CodeGroup title="SSE Message" tag="SSE_Message" label="Message Types">

```python {{ title: 'Simple Message' }}
from robyn import SSE_Message

# Basic message with just data
message = SSE_Message("Hello, Batman!")

# Message with event type
message = SSE_Message("Crime alert!", event="alert")

# Message with ID for client tracking
message = SSE_Message("Status update", id="status-1")
```

```python {{ title: 'Complete Message' }}
from robyn import SSE_Message

# Full message with all parameters
message = SSE_Message(
    data="System operational",
    event="status",
    id="sys-001",
    retry=5000  # 5 seconds
)
```

</CodeGroup>
</Col>
</Row>

---

## Named Events {{ tag: 'NamedEvents', label: 'Named Events' }}

<Row>
<Col>
Batman can send different types of events to his dashboard, allowing the client to handle each event type differently. This is particularly useful for applications that need to distinguish between different kinds of updates.
</Col>
<Col sticky>

<CodeGroup title="Named Events" tag="GET" label="/events/named">

```python {{ title: 'Multiple Event Types' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events/named")
def stream_named_events(request):
    def named_event_generator():
        events = [
            ("alert", "Joker spotted in downtown"),
            ("update", "Police units dispatched"),
            ("status", "Situation under control"),
            ("alert", "New crime reported"),
        ]
        
        for event_type, message in events:
            yield SSE_Message(
                message, 
                event=event_type, 
                id=f"{event_type}-{time.time()}"
            )
            time.sleep(1.5)
    
    return SSE_Response(named_event_generator())
```

```python {{ title: 'Client-side JavaScript' }}
// HTML/JavaScript client code
const eventSource = new EventSource('/events/named');

// Listen for specific event types
eventSource.addEventListener('alert', function(event) {
    console.log('Alert:', event.data);
    showAlert(event.data);
});

eventSource.addEventListener('update', function(event) {
    console.log('Update:', event.data);
    updateStatus(event.data);
});

eventSource.addEventListener('status', function(event) {
    console.log('Status:', event.data);
    updateSystemStatus(event.data);
});
```

</CodeGroup>
</Col>
</Row>

---

## Async SSE Streams {{ tag: 'AsyncSSE', label: 'Async Streams' }}

<Row>
<Col>
For I/O-bound operations or when Batman needs to fetch data from external sources, async generators provide better performance by not blocking the event loop.
</Col>
<Col sticky>

<CodeGroup title="Async SSE" tag="GET" label="/events/async">

```python {{ title: 'Async Generator' }}
from robyn import Robyn, SSE_Response, SSE_Message
import asyncio
import time

app = Robyn(__file__)

@app.get("/events/async")
async def stream_async_events(request):
    async def async_event_generator():
        for i in range(8):
            # Simulate async database call
            await asyncio.sleep(0.5)
            
            yield SSE_Message(
                f"Async update {i} - {time.strftime('%H:%M:%S')}", 
                event="async_update", 
                id=str(i)
            )
    
    return SSE_Response(async_event_generator())
```

```python {{ title: 'Database Integration' }}
from robyn import Robyn, SSE_Response, SSE_Message
import asyncio
import json

app = Robyn(__file__)

@app.get("/events/database")
async def stream_database_events(request):
    async def database_event_generator():
        while True:
            # Simulate async database query
            await asyncio.sleep(2)
            
            # Fetch latest crime reports
            crime_data = await get_latest_crimes()
            
            yield SSE_Message(
                json.dumps(crime_data),
                event="crime_update",
                id=f"crime-{time.time()}"
            )

async def get_latest_crimes():
    # Simulate database call
    await asyncio.sleep(0.1)
    return {"location": "Gotham Square", "type": "theft"}
```

</CodeGroup>
</Col>
</Row>

---

## Heartbeat and Connection Management {{ tag: 'Heartbeat', label: 'Heartbeat' }}

<Row>
<Col>
Batman needs to ensure his dashboard stays connected to the server. Heartbeat messages help maintain the connection and detect when clients disconnect.
</Col>
<Col sticky>

<CodeGroup title="Heartbeat" tag="GET" label="/events/heartbeat">

```python {{ title: 'Heartbeat Stream' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events/heartbeat")
def stream_heartbeat(request):
    def heartbeat_generator():
        counter = 0
        while counter < 20:  # Send 20 heartbeats
            yield SSE_Message(
                f"ping {counter}", 
                event="heartbeat", 
                id=str(counter)
            )
            counter += 1
            time.sleep(0.5)
        
        # Signal end of stream
        yield SSE_Message("heartbeat ended", event="end")
    
    return SSE_Response(heartbeat_generator())
```

```python {{ title: 'Connection Status' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events/status")
def stream_status(request):
    def status_generator():
        # Send connection established message
        yield SSE_Message("Connected to Batcave", event="connected")
        
        # Send periodic status updates
        for i in range(10):
            status = {
                "timestamp": time.time(),
                "systems": "operational",
                "connections": i + 1
            }
            yield SSE_Message(
                json.dumps(status),
                event="status_update",
                id=f"status-{i}"
            )
            time.sleep(3)
        
        # Send disconnection message
        yield SSE_Message("Disconnecting", event="disconnect")
    
    return SSE_Response(status_generator())
```

</CodeGroup>
</Col>
</Row>

---

## Error Handling {{ tag: 'ErrorHandling', label: 'Error Handling' }}

<Row>
<Col>
Batman ensures his SSE streams are robust by implementing proper error handling. This prevents streams from crashing and provides meaningful error messages to clients.
</Col>
<Col sticky>

<CodeGroup title="Error Handling" tag="GET" label="/events/robust">

```python {{ title: 'Error Handling' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time
import logging

app = Robyn(__file__)

@app.get("/events/robust")
def stream_robust_events(request):
    def robust_event_generator():
        try:
            for i in range(10):
                try:
                    # Simulate potential error
                    if i == 5:
                        raise ValueError("Simulated error")
                    
                    yield SSE_Message(
                        f"Event {i} processed successfully",
                        event="success",
                        id=str(i)
                    )
                    time.sleep(1)
                    
                except ValueError as e:
                    # Send error message to client
                    yield SSE_Message(
                        f"Error processing event {i}: {str(e)}",
                        event="error",
                        id=f"error-{i}"
                    )
                    logging.error(f"SSE error: {e}")
                    continue
                    
        except Exception as e:
            # Send final error message
            yield SSE_Message(
                f"Stream ended due to error: {str(e)}",
                event="stream_error"
            )
    
    return SSE_Response(robust_event_generator())
```

```python {{ title: 'Client Reconnection' }}
// Client-side reconnection handling
const eventSource = new EventSource('/events/robust');

eventSource.addEventListener('error', function(event) {
    console.log('SSE error occurred:', event);
    
    // Implement reconnection logic
    setTimeout(() => {
        console.log('Attempting to reconnect...');
        connectToSSE();
    }, 5000);
});

eventSource.addEventListener('stream_error', function(event) {
    console.log('Stream error:', event.data);
    eventSource.close();
    
    // Show user notification
    showNotification('Connection lost. Attempting to reconnect...');
});

function connectToSSE() {
    const eventSource = new EventSource('/events/robust');
    // ... setup event listeners
}
```

</CodeGroup>
</Col>
</Row>

---

## Complete Example {{ tag: 'CompleteExample', label: 'Complete Example' }}

<Row>
<Col>
Here's Batman's complete SSE implementation for his crime monitoring dashboard, including an HTML client and multiple event types.
</Col>
<Col sticky>

<CodeGroup title="Complete Example" tag="Application" label="Full SSE App">

```python {{ title: 'Server Implementation' }}
from robyn import Robyn, SSE_Response, SSE_Message, html
import time
import json
import asyncio

app = Robyn(__file__)

@app.get("/")
def index(request):
    return html("""
    <!DOCTYPE html>
    <html>
    <head>
        <title>Batman's Crime Dashboard</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            #events { border: 1px solid #ccc; padding: 20px; height: 400px; overflow-y: auto; }
            .event { margin: 5px 0; padding: 10px; border-radius: 5px; }
            .alert { background-color: #ffebee; border-left: 4px solid #f44336; }
            .update { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
            .status { background-color: #e3f2fd; border-left: 4px solid #2196f3; }
        </style>
    </head>
    <body>
        <h1>ü¶á Batman's Crime Dashboard</h1>
        <div id="events"></div>
        
        <script>
            const eventSource = new EventSource('/events/dashboard');
            const eventsDiv = document.getElementById('events');
            
            eventSource.addEventListener('alert', function(event) {
                addEvent(event.data, 'alert');
            });
            
            eventSource.addEventListener('update', function(event) {
                addEvent(event.data, 'update');
            });
            
            eventSource.addEventListener('status', function(event) {
                addEvent(event.data, 'status');
            });
            
            function addEvent(data, type) {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'event ' + type;
                eventDiv.innerHTML = '<strong>' + type.toUpperCase() + ':</strong> ' + data;
                eventsDiv.appendChild(eventDiv);
                eventsDiv.scrollTop = eventsDiv.scrollHeight;
            }
        </script>
    </body>
    </html>
    """)

@app.get("/events/dashboard")
def stream_dashboard_events(request):
    def dashboard_event_generator():
        # Initial status
        yield SSE_Message("Dashboard connected", event="status")
        
        # Simulate various events
        events = [
            ("alert", "üö® Crime detected at Wayne Manor"),
            ("update", "üì° Police units dispatched"),
            ("status", "üîç Investigating suspicious activity"),
            ("alert", "‚ö†Ô∏è Joker spotted downtown"),
            ("update", "üöî Backup requested"),
            ("status", "‚úÖ Area secured"),
        ]
        
        for event_type, message in events:
            yield SSE_Message(message, event=event_type, id=f"{event_type}-{time.time()}")
            time.sleep(2)
    
    return SSE_Response(dashboard_event_generator())

if __name__ == "__main__":
    app.start(host="0.0.0.0", port=8080)
```

</CodeGroup>
</Col>
</Row>

---

## Best Practices {{ tag: 'BestPractices', label: 'Best Practices' }}

<Row>
<Col>
Batman follows these best practices to ensure his SSE implementation is robust, scalable, and maintainable:

**Performance:**
- Use async generators for I/O-bound operations
- Implement proper connection limits
- Add heartbeat mechanisms for long-running streams

**Error Handling:**
- Always wrap generators in try-catch blocks
- Send error messages to clients when appropriate
- Log errors for debugging

**Client-Side:**
- Implement reconnection logic
- Handle different event types appropriately
- Close connections when no longer needed

**Security:**
- Validate client connections
- Implement rate limiting
- Use HTTPS in production
</Col>
<Col sticky>

<CodeGroup title="Best Practices" tag="Tips" label="Implementation Tips">

```python {{ title: 'Production Ready' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time
import logging
from typing import Generator

app = Robyn(__file__)

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.get("/events/production")
def stream_production_events(request):
    def production_event_generator() -> Generator[SSE_Message, None, None]:
        client_id = request.headers.get("X-Client-ID", "unknown")
        logger.info(f"SSE client connected: {client_id}")
        
        try:
            # Send initial connection message
            yield SSE_Message(
                "Connected to production stream",
                event="connected",
                id="conn-1"
            )
            
            # Main event loop
            for i in range(100):  # Limit number of events
                try:
                    # Your business logic here
                    data = get_production_data(i)
                    
                    yield SSE_Message(
                        data,
                        event="data_update",
                        id=f"data-{i}",
                        retry=5000  # 5 second retry
                    )
                    
                    time.sleep(1)
                    
                except Exception as e:
                    logger.error(f"Error in SSE stream: {e}")
                    yield SSE_Message(
                        "Temporary error occurred",
                        event="error"
                    )
                    continue
                    
        except Exception as e:
            logger.error(f"SSE stream crashed: {e}")
            yield SSE_Message(
                "Stream ended due to error",
                event="stream_end"
            )
        finally:
            logger.info(f"SSE client disconnected: {client_id}")
    
    return SSE_Response(production_event_generator())

def get_production_data(index: int) -> str:
    # Simulate data fetching
    return f"Production data {index}"
```

</CodeGroup>
</Col>
</Row>

---

## What's next?

Batman has mastered Server-Sent Events and can now stream real-time updates to his crime dashboard. While SSE is perfect for one-way communication from server to client, Batman realizes he needs bidirectional communication for more interactive features like real-time chat with his allies.

Next, he wants to explore how to handle bidirectional communication with [WebSockets](/documentation/en/api_reference/websockets) for more interactive features.

If Batman needs to handle unexpected situations, he'll learn about [Exception handling](/documentation/en/api_reference/exceptions) to make his applications more robust.

For scaling his crime monitoring system across multiple processes, Batman will explore [Scaling the Application](/documentation/en/api_reference/scaling).

---

**Previous:** [WebSockets](/documentation/en/api_reference/websockets) - Learn how to use WebSockets in Robyn  
**Next:** [Exceptions](/documentation/en/api_reference/exceptions) - Learn how to handle exceptions in Robyn

Ready to implement real-time features in your Robyn application? Server-Sent Events provide a simple yet powerful way to stream data from server to client!
