export const description =
  'On this page, we’ll dive into the different conversation endpoints you can use to manage conversations programmatically.'


## Request Object

The request object is a dataclass that contains all the information about the request. It is available in the route handler as the first argument.



<Row>
<Col>
The request object is created in Rust side but is exposed to Python as a dataclass.

<ul>
<li>
Attributes:
</li>
<li>
query_params (QueryParams): The query parameters of the request. `e.g. /user?id=123 -> {"id": [ "123" ]}`
</li>
<li>
headers (dict[str, str]): The headers of the request. `e.g. {"Content-Type": "application/json"}`
</li>
<li>
params (dict[str, str]): The parameters of the request. `e.g. /user/:id -> {"id": "123"}`
</li>
<li>
body (Union[str, bytes]): The raw body of the request. For JSON payloads, use the `json()` method to parse the body into a dict with proper type preservation.
</li>
<li>
method (str): The method of the request. `e.g. GET, POST, PUT, DELETE`
</li>
<li>
ip_addr (Optional[str]): The IP Address of the client
</li>
<li>
identity (Optional[Identity]): The identity of the client
</li>


</ul>





</Col>
  <Col>

    <CodeGroup title="Request" tag="GET" label="/hello_world">

    ```python
    @dataclass
    class Request:
      """
      query_params: QueryParams
      headers: Headers
      path_params: dict[str, str]
      body: Union[str, bytes]
      method: str
      url: Url
      form_data: dict[str, str]
      files: dict[str, bytes]
      ip_addr: Optional[str]
      identity: Optional[Identity]
      """
    ```
    </CodeGroup>
  </Col>
</Row>

## Parsing JSON Body

The `request.json()` method parses the request body as JSON and returns a Python `dict` with full type preservation:

- JSON `null` becomes Python `None`
- JSON numbers become Python `int` or `float`
- JSON booleans become Python `bool`
- JSON strings become Python `str`
- JSON arrays become Python `list`
- JSON objects become Python `dict`

Nested structures are handled recursively up to a maximum depth of 128 levels.

<CodeGroup title="Parsing JSON" tag="POST" label="/example">

```python
@app.post("/example")
async def handler(request: Request):
    data = request.json()  # Returns a dict with preserved types
    # e.g. {"count": 42, "active": true, "tags": ["a", "b"]}
    # ->   {"count": 42, "active": True, "tags": ["a", "b"]}
    return {"received": data}
```
</CodeGroup>

If the body is not valid JSON or is not a JSON object, a `ValueError` will be raised.

## Extra Path Parameters

Robyn supports capturing extra path parameters using the `*extra` syntax in route definitions. This allows you to capture any additional segments in the URL path that come after the defined route.

For example, if you define a route like this:

<CodeGroup>
```python
@app.get("/sync/extra/*extra")
def sync_param_extra(request: Request):
    extra = request.path_params["extra"]
    return extra
```
</CodeGroup>

Any additional path segments after `/sync/extra/` will be captured in the `extra` parameter. For instance:

<ul>
<li>
A request to `/sync/extra/foo/bar` would result in `extra = "foo/bar"`
</li>
<li>
     A request to `/sync/extra/123/456/789` would result in `extra = "123/456/789"`
</li>
</ul>

You can access the extra path parameters through `request.path_params["extra"]` in your route handler.

This feature is particularly useful when you need to handle dynamic, nested routes or when you want to capture an unknown number of path segments.

---

## Easy Access Parameters

Instead of manually extracting and converting query parameters and path parameters from the request object, you can declare them directly in your function signature with type annotations. Robyn will automatically resolve and coerce them for you.

Any handler parameter that doesn't match a known request component (`Request`, `QueryParams`, `Headers`, etc.) is treated as an individual path or query parameter.

<Row>
  <Col>
    **Basic usage** — path params and query params with type coercion and defaults.
  </Col>
  <Col sticky>
    <CodeGroup title="Easy Access Params" tag="GET" label="/items/:id?q=hello&page=5">

    ```python {{ title: 'Typed Params' }}
    @app.get("/items/:id")
    async def get_item(id: int, q: str, page: int = 1):
        # id is coerced from the path param string to int
        # q is taken from ?q=...
        # page defaults to 1 if not provided
        return {"id": id, "q": q, "page": page}
    ```

    ```python {{ title: 'Mixed with Request' }}
    @app.get("/items/:id")
    async def get_item(request: Request, id: int, q: str = ""):
        # request is still injected as usual
        # id and q are resolved as individual params
        return {"id": id, "q": q, "method": request.method}
    ```
    </CodeGroup>
  </Col>
</Row>

<Row>
  <Col>
    **Optional, List, Bool, and Float params** — Robyn handles common Python types automatically.

    - `Optional[T]` — resolves to `None` when not provided
    - `List[T]` — collects repeated query params (e.g. `?tag=a&tag=b`)
    - `bool` — accepts `true/false`, `1/0`, `yes/no`, `on/off`
    - `float` — standard float coercion
  </Col>
  <Col sticky>
    <CodeGroup title="Advanced Types" tag="GET" label="/search">

    ```python {{ title: 'Optional' }}
    @app.get("/search")
    def search(name: str, age: Optional[int] = None):
        return {"name": name, "age": age}
    # GET /search?name=bob        -> {"name": "bob", "age": null}
    # GET /search?name=bob&age=30 -> {"name": "bob", "age": 30}
    ```

    ```python {{ title: 'List' }}
    from typing import List

    @app.get("/filter")
    def filter_items(tag: List[str]):
        return {"tags": tag}
    # GET /filter?tag=python&tag=rust -> {"tags": ["python", "rust"]}
    ```

    ```python {{ title: 'Bool & Float' }}
    @app.get("/settings")
    def settings(active: bool = False, price: float = 0.0):
        return {"active": active, "price": price}
    # GET /settings?active=true&price=19.99
    # -> {"active": true, "price": 19.99}
    ```
    </CodeGroup>
  </Col>
</Row>

<Row>
  <Col>
    **Error handling** — if a required parameter is missing or a value cannot be coerced to the declared type, Robyn returns a `400 Bad Request` response automatically.
  </Col>
  <Col sticky>
    <CodeGroup title="Validation Errors" tag="GET" label="/items/:id">

    ```python {{ title: 'Automatic 400' }}
    @app.get("/items/:id")
    def get_item(id: int, q: str):
        return {"id": id, "q": q}

    # GET /items/42         -> 400 (missing required 'q')
    # GET /items/abc?q=test -> 400 (cannot coerce 'abc' to int)
    ```
    </CodeGroup>
  </Col>
</Row>

---


## What's next?

Now, Batman wanted to understand the configuration of the Robyn server. He was then introduced to the concept of Robyn env files.

- [Robyn Env](/documentation/en/api_reference/robyn_env)

