export const description =
  '学习如何在 Robyn 中实现服务器发送事件 (SSE)，用于实时的服务器到客户端通信。'

## 服务器发送事件 (SSE) {{ tag: 'SSE', label: 'Server-Sent Events' }}

<Row>
<Col>
在学习了[表单数据处理](/documentation/zh/api_reference/form_data)之后，蝙蝠侠意识到他需要一种方法来向他的犯罪监控仪表板推送实时更新。犯罪分子不会等待蝙蝠侠刷新浏览器！

他发现了服务器发送事件 (SSE) - 一个完美的解决方案，用于通过 HTTP 进行服务器到客户端的单向通信。SSE 允许蝙蝠侠将实时数据流式传输到他的仪表板，而无需完整双向通信的复杂性。

"这正是我的犯罪警报系统所需要的！"蝙蝠侠惊呼道。"我可以在检测到新犯罪时立即向仪表板推送更新。"

服务器发送事件非常适合：
- 实时通知
- 实时数据源
- 进度更新
- 聊天应用程序（仅服务器到客户端）
- 仪表板更新
- 日志流式传输
</Col>
<Col sticky>

<CodeGroup title="SSE 响应" tag="GET" label="/events">

```python {{ title: '基本 SSE 流' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events")
def stream_events(request):
    def event_generator():
        for i in range(10):
            yield SSE_Message(f"事件 {i}", id=str(i))
            time.sleep(1)
    
    return SSE_Response(event_generator())
```

```python {{ title: 'JSON 数据流' }}
from robyn import Robyn, SSE_Response, SSE_Message
import json
import time

app = Robyn(__file__)

@app.get("/events/json")
def stream_json_events(request):
    def json_event_generator():
        for i in range(5):
            data = {
                "id": i,
                "message": f"更新 {i}",
                "timestamp": time.time()
            }
            yield SSE_Message(
                json.dumps(data), 
                event="update", 
                id=str(i)
            )
            time.sleep(2)
    
    return SSE_Response(json_event_generator())
```

</CodeGroup>
</Col>
</Row>

---

## SSE 消息格式 {{ tag: 'SSE_Message', label: 'Message Format' }}

<Row>
<Col>
`SSE_Message` 类提供了一种结构化的方式来格式化服务器发送事件。您可以指定消息数据、事件类型和唯一标识符。

**SSE_Message 参数：**
- `data`: 消息内容（必需）
- `event`: 用于客户端过滤的事件类型（可选）
- `id`: 消息的唯一标识符（可选）
- `retry`: 重连时间（毫秒）（可选）
</Col>
<Col sticky>

<CodeGroup title="SSE 消息" tag="SSE_Message" label="消息类型">

```python {{ title: '简单消息' }}
from robyn import SSE_Message

# 只有数据的基本消息
message = SSE_Message("你好，蝙蝠侠！")

# 带有事件类型的消息
message = SSE_Message("犯罪警报！", event="alert")

# 带有 ID 的消息用于客户端跟踪
message = SSE_Message("状态更新", id="status-1")
```

```python {{ title: '完整消息' }}
from robyn import SSE_Message

# 包含所有参数的完整消息
message = SSE_Message(
    data="系统正常运行",
    event="status",
    id="sys-001",
    retry=5000  # 5 秒
)
```

</CodeGroup>
</Col>
</Row>

---

## 命名事件 {{ tag: 'NamedEvents', label: 'Named Events' }}

<Row>
<Col>
蝙蝠侠可以向他的仪表板发送不同类型的事件，允许客户端以不同的方式处理每种事件类型。这对于需要区分不同类型更新的应用程序特别有用。
</Col>
<Col sticky>

<CodeGroup title="命名事件" tag="GET" label="/events/named">

```python {{ title: '多种事件类型' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events/named")
def stream_named_events(request):
    def named_event_generator():
        events = [
            ("alert", "小丑在市中心被发现"),
            ("update", "警察单位已派遣"),
            ("status", "情况已控制"),
            ("alert", "新犯罪报告"),
        ]
        
        for event_type, message in events:
            yield SSE_Message(
                message, 
                event=event_type, 
                id=f"{event_type}-{time.time()}"
            )
            time.sleep(1.5)
    
    return SSE_Response(named_event_generator())
```

```python {{ title: '客户端 JavaScript' }}
// HTML/JavaScript 客户端代码
const eventSource = new EventSource('/events/named');

// 监听特定事件类型
eventSource.addEventListener('alert', function(event) {
    console.log('警报:', event.data);
    showAlert(event.data);
});

eventSource.addEventListener('update', function(event) {
    console.log('更新:', event.data);
    updateStatus(event.data);
});

eventSource.addEventListener('status', function(event) {
    console.log('状态:', event.data);
    updateSystemStatus(event.data);
});
```

</CodeGroup>
</Col>
</Row>

---

## 异步 SSE 流 {{ tag: 'AsyncSSE', label: 'Async Streams' }}

<Row>
<Col>
对于 I/O 密集型操作或当蝙蝠侠需要从外部源获取数据时，异步生成器通过不阻塞事件循环提供更好的性能。
</Col>
<Col sticky>

<CodeGroup title="异步 SSE" tag="GET" label="/events/async">

```python {{ title: '异步生成器' }}
from robyn import Robyn, SSE_Response, SSE_Message
import asyncio
import time

app = Robyn(__file__)

@app.get("/events/async")
async def stream_async_events(request):
    async def async_event_generator():
        for i in range(8):
            # 模拟异步数据库调用
            await asyncio.sleep(0.5)
            
            yield SSE_Message(
                f"异步更新 {i} - {time.strftime('%H:%M:%S')}", 
                event="async_update", 
                id=str(i)
            )
    
    return SSE_Response(async_event_generator())
```

```python {{ title: '数据库集成' }}
from robyn import Robyn, SSE_Response, SSE_Message
import asyncio
import json

app = Robyn(__file__)

@app.get("/events/database")
async def stream_database_events(request):
    async def database_event_generator():
        while True:
            # 模拟异步数据库查询
            await asyncio.sleep(2)
            
            # 获取最新犯罪报告
            crime_data = await get_latest_crimes()
            
            yield SSE_Message(
                json.dumps(crime_data),
                event="crime_update",
                id=f"crime-{time.time()}"
            )

async def get_latest_crimes():
    # 模拟数据库调用
    await asyncio.sleep(0.1)
    return {"location": "哥谭广场", "type": "盗窃"}
```

</CodeGroup>
</Col>
</Row>

---

## 完整示例 {{ tag: 'CompleteExample', label: 'Complete Example' }}

<Row>
<Col>
这是蝙蝠侠为他的犯罪监控仪表板完整的 SSE 实现，包括一个 HTML 客户端和多种事件类型。
</Col>
<Col sticky>

<CodeGroup title="完整示例" tag="Application" label="完整 SSE 应用">

```python {{ title: '服务器实现' }}
from robyn import Robyn, SSE_Response, SSE_Message, html
import time
import json

app = Robyn(__file__)

@app.get("/")
def index(request):
    return html("""
    <!DOCTYPE html>
    <html>
    <head>
        <title>蝙蝠侠的犯罪仪表板</title>
        <style>
            body { font-family: Arial, sans-serif; margin: 40px; }
            #events { border: 1px solid #ccc; padding: 20px; height: 400px; overflow-y: auto; }
            .event { margin: 5px 0; padding: 10px; border-radius: 5px; }
            .alert { background-color: #ffebee; border-left: 4px solid #f44336; }
            .update { background-color: #e8f5e8; border-left: 4px solid #4caf50; }
            .status { background-color: #e3f2fd; border-left: 4px solid #2196f3; }
        </style>
    </head>
    <body>
        <h1>🦇 蝙蝠侠的犯罪仪表板</h1>
        <div id="events"></div>
        
        <script>
            const eventSource = new EventSource('/events/dashboard');
            const eventsDiv = document.getElementById('events');
            
            eventSource.addEventListener('alert', function(event) {
                addEvent(event.data, 'alert');
            });
            
            eventSource.addEventListener('update', function(event) {
                addEvent(event.data, 'update');
            });
            
            eventSource.addEventListener('status', function(event) {
                addEvent(event.data, 'status');
            });
            
            function addEvent(data, type) {
                const eventDiv = document.createElement('div');
                eventDiv.className = 'event ' + type;
                eventDiv.innerHTML = '<strong>' + type.toUpperCase() + ':</strong> ' + data;
                eventsDiv.appendChild(eventDiv);
                eventsDiv.scrollTop = eventsDiv.scrollHeight;
            }
        </script>
    </body>
    </html>
    """)

@app.get("/events/dashboard")
def stream_dashboard_events(request):
    def dashboard_event_generator():
        # 初始状态
        yield SSE_Message("仪表板已连接", event="status")
        
        # 模拟各种事件
        events = [
            ("alert", "🚨 韦恩庄园发现犯罪"),
            ("update", "📡 警察单位已派遣"),
            ("status", "🔍 正在调查可疑活动"),
            ("alert", "⚠️ 小丑在市中心被发现"),
            ("update", "🚔 请求支援"),
            ("status", "✅ 区域已安全"),
        ]
        
        for event_type, message in events:
            yield SSE_Message(message, event=event_type, id=f"{event_type}-{time.time()}")
            time.sleep(2)
    
    return SSE_Response(dashboard_event_generator())

if __name__ == "__main__":
    app.start(host="0.0.0.0", port=8080)
```

</CodeGroup>
</Col>
</Row>

---

## 最佳实践 {{ tag: 'BestPractices', label: 'Best Practices' }}

<Row>
<Col>
蝙蝠侠遵循这些最佳实践来确保他的 SSE 实现健壮、可扩展且易于维护：

**性能：**
- 对 I/O 密集型操作使用异步生成器
- 实现适当的连接限制
- 为长时间运行的流添加心跳机制

**错误处理：**
- 始终将生成器包装在 try-catch 块中
- 在适当时向客户端发送错误消息
- 记录错误以便调试

**客户端：**
- 实现重连逻辑
- 适当处理不同事件类型
- 不再需要时关闭连接

**安全性：**
- 验证客户端连接
- 实现速率限制
- 在生产环境中使用 HTTPS
</Col>
<Col sticky>

<CodeGroup title="最佳实践" tag="Tips" label="实现技巧">

```python {{ title: '生产就绪' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time
import logging
from typing import Generator

app = Robyn(__file__)

# 配置日志
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

@app.get("/events/production")
def stream_production_events(request):
    def production_event_generator() -> Generator[SSE_Message, None, None]:
        client_id = request.headers.get("X-Client-ID", "unknown")
        logger.info(f"SSE 客户端已连接: {client_id}")
        
        try:
            # 发送初始连接消息
            yield SSE_Message(
                "已连接到生产流",
                event="connected",
                id="conn-1"
            )
            
            # 主事件循环
            for i in range(100):  # 限制事件数量
                try:
                    # 您的业务逻辑在这里
                    data = get_production_data(i)
                    
                    yield SSE_Message(
                        data,
                        event="data_update",
                        id=f"data-{i}",
                        retry=5000  # 5 秒重试
                    )
                    
                    time.sleep(1)
                    
                except Exception as e:
                    logger.error(f"SSE 流中的错误: {e}")
                    yield SSE_Message(
                        "发生临时错误",
                        event="error"
                    )
                    continue
                    
        except Exception as e:
            logger.error(f"SSE 流崩溃: {e}")
            yield SSE_Message(
                "由于错误流已结束",
                event="stream_end"
            )
        finally:
            logger.info(f"SSE 客户端已断开连接: {client_id}")
    
    return SSE_Response(production_event_generator())

def get_production_data(index: int) -> str:
    # 模拟数据获取
    return f"生产数据 {index}"
```

</CodeGroup>
</Col>
</Row>

---

## 接下来做什么？

蝙蝠侠已经掌握了服务器发送事件，现在可以向他的犯罪仪表板流式传输实时更新。虽然 SSE 非常适合服务器到客户端的单向通信，但蝙蝠侠意识到他需要双向通信来实现更多交互功能，比如与他的盟友进行实时聊天。

接下来，他想探索如何使用 [WebSocket](/documentation/zh/api_reference/websockets) 处理双向通信，以获得更多交互功能。

如果蝙蝠侠需要处理意外情况，他将学习[异常处理](/documentation/zh/api_reference/exceptions)以使他的应用程序更加健壮。

为了将他的犯罪监控系统扩展到多个进程，蝙蝠侠将探索[多核扩展](/documentation/zh/api_reference/scaling)。

---

**上一页：** [WebSocket](/documentation/zh/api_reference/websockets) - 学习如何在 Robyn 中使用 WebSocket  
**下一页：** [异常处理](/documentation/zh/api_reference/exceptions) - 学习如何在 Robyn 中处理异常

准备在您的 Robyn 应用程序中实现实时功能了吗？服务器发送事件提供了一种简单而强大的方式来从服务器向客户端流式传输数据！