export const description =
  '学习如何在 Robyn 中实现服务器发送事件 (SSE)，用于实时的服务器到客户端通信。'

## 服务器发送事件 (SSE)

在学习了[表单数据处理](/documentation/zh/api_reference/form_data)之后，蝙蝠侠意识到他需要一种方法来向他的犯罪监控仪表板推送实时更新。犯罪分子不会等待蝙蝠侠刷新浏览器！

他发现了服务器发送事件 (SSE) - 一个完美的解决方案，用于通过 HTTP 进行服务器到客户端的单向通信。SSE 允许蝙蝠侠将实时数据流式传输到他的仪表板，而无需完整双向通信的复杂性。

"这正是我的犯罪警报系统所需要的！"蝙蝠侠惊呼道。"我可以在检测到新犯罪时立即向仪表板推送更新。"

服务器发送事件非常适合：
- 实时通知
- 实时数据源
- 进度更新
- 聊天应用程序（仅服务器到客户端）
- 仪表板更新
- 日志流式传输

<Row>
<Col>

蝙蝠侠可以使用 `SSE_Response` 和 `SSE_Message` 类创建服务器发送事件流：

</Col>
<Col sticky>

<CodeGroup title="SSE 响应" tag="GET" label="/events">

```python {{ title: '基本 SSE 流' }}
from robyn import Robyn, SSE_Response, SSE_Message
import time

app = Robyn(__file__)

@app.get("/events")
def stream_events(request):
    def event_generator():
        for i in range(10):
            yield SSE_Message(f"事件 {i}", id=str(i))
            time.sleep(1)
    
    return SSE_Response(event_generator())
```

```python {{ title: 'JSON 数据流' }}
from robyn import Robyn, SSE_Response, SSE_Message
import json
import time

app = Robyn(__file__)

@app.get("/events/json")
def stream_json_events(request):
    def json_event_generator():
        for i in range(5):
            data = {
                "id": i,
                "message": f"更新 {i}",
                "timestamp": time.time()
            }
            yield SSE_Message(
                json.dumps(data), 
                event="update", 
                id=str(i)
            )
            time.sleep(2)
    
    return SSE_Response(json_event_generator())
```

</CodeGroup>
</Col>
</Row>

---

## 接下来做什么？

蝙蝠侠已经掌握了服务器发送事件，现在可以向他的犯罪仪表板流式传输实时更新。虽然 SSE 非常适合服务器到客户端的单向通信，但蝙蝠侠意识到他需要双向通信来实现更多交互功能，比如与他的盟友进行实时聊天。

接下来，他想探索如何使用 [WebSocket](/documentation/zh/api_reference/websockets) 处理双向通信，以获得更多交互功能。

如果蝙蝠侠需要处理意外情况，他将学习[异常处理](/documentation/zh/api_reference/exceptions)以使他的应用程序更加健壮。

为了将他的犯罪监控系统扩展到多个进程，蝙蝠侠将探索[多核扩展](/documentation/zh/api_reference/scaling)。

